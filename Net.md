
网络连接的旅程：
从7层模型开始

应用层
HTTP和HTTPS有什么区别？

1. 端口不同：HTTP使用的是80端口，HTTPS使用443端口；
2. HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；
3. HTTPS由于加密解密会带来更大的CPU和内存开销；
4. HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买

HTTPS的链接过程？

什么是对称加密，什么是非对称加密？
数字签名，报文摘要的原理？

GET和POST的区别？
Session与Cookie的区别？

从输入网址到获得页面的过程 (越详细越好)？

HTTP请求有哪些常见状态码？


1.开始：在浏览器中输入网址：https://github.com/isyiming
   1.1@ 解析URL含义：
        -web服务器：http:  http协议
                -URI（统一资源标识符）对什么进行操作：一个存放网页数据的文件名或者一个CGI程序
                -方法：进行什么操作，例如读取URI表示的数据、将客户端输入数据发送给URI表示的程序。http的主要方法：get、post、head…
        -ftp服务器：ftp:        ftp协议
        -根据访问目标不同，URL的写法有区别。web和ftp服务器的URL一般都包含服务器的域名和要访问的文件路径名，发邮件的URL包含收件人的邮件地址
        -URL组成举例： -http://user:password@www.glasscom.com:80/dir/file1.htm -用户名（可省略）+密码（可省略）+web服务器域名+端口号（可省略）+文件路径名（如果文件路径存在省略的情况，服务器会根据设定访问默认文件）

   1.2@生成http请求消息
        -对URL解析后，确定了web服务器和文件名
        -根据以上信息生成HTTP请求：
                -请求行：第一行，<方法>< ><URI>< ><HTTP版本> 请求行中的方法根据浏览器的工作状态确定，例如网页中的确认按钮，提交按钮
                -消息头：第二行开始，消息头内容可包括：如日期、客户端支持的 数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有 效期和最后更新时间等
                -空行

   1.3@向DNS服务器查询web服务器的ip
    -socket库操作，调用解析器，根据域名查询ip
    -DNS服务器接受客户端的查询消息：域名+class(只是代表互联网的in)+记录类型（有A代表ip，MX代表邮件地址）
    -DNS服务器利用缓存机制加快查询速度，缓存数据每隔一段时间就删除，因为域名信息可能随时更新。

1.4@委托协议栈发送消息
    -调用socket库组件，创建套接字，建立连接。
    -服务器启动的时候就会创建套接字，等待客户端连接（创建状态）
    -客户端创建套接字连接服务器（连接状态）创建套接字连接时提供了ip和端口号，web端口80，电子邮件端口25
    -收发数据（通信状态）
    -断开管道删除套接字（结束状态）
表示层：
* 功能：图像、视频编码解，数据加密。
会话层：
* 功能：建立会话，如session认证、断点续传。

传输层
2.TCP/IP 协议栈和网络硬件（网卡）
    -TCP协议：浏览器 邮件等一般的应用程序
      -TCP协议头部：
      -MTU:一个网络包的最大长度，以太网中一般为 1500 字节.MSS:除去头部之后，一个网络包所能容纳的 TCP 数据的最大 长度。

TCP协议将每一个发送的包大包为TCP header+TCP data

TCP协议头部：

发送方端口号
接受放端口号
seq序号
ACK号
数据偏移量
根据偏移量可以知道data从那里开始
保留字段

控制位
接收通告窗口大小告诉对方本端的TCP缓冲区还可以容纳的数据量
校验和
检查是否出现错误
紧急指针+可选字段
除了上面的固定头部字段之外，还可以添加可选字段
8个控制位
CWR(Congestion Window Reduce)
ECE(ECN Echo)
URG(Urgent)
表示紧急(The urgent pointer) 标志有效
ACK(Acknowledgment)
取值1代表Acknowledgment Number字段有效
PSH(Push)
表示发送端缓存中已经没有待发送的数据
RST(Reset)
在发生异常或者错误的时候会触发复位TCP连接
SYN(Synchronize)
同步序列编号
仅在三次握手时使用
FIN(Finish)
在四次挥手时用来标记结束一个TCP会话


TCP协议的三次握手过程：
如果按照三次握手的顺序介绍，未免有些繁琐。首先总结一下TCP协议传输数据的要求：
* 建立链接的两方的TCP头部都需要有一个seq序号用来标记建立连接后自己发送过多少包，这个seq序号的初始值都是随机产生的。
* 作为接受方时，再次发送包总要将新包的TCP头部的ack序号记为接收包的seq序号+1
这两点总结之后我们可以简单描述下双方的控制位的变化，就可以概括三次握手的全过程。
* 第一次握手：Client的syn置1表示建立连接，进入syn_sent状态，等待server确认接收
* 第二次握手：Server的syn和ack都置1，进入syn_rcvd状态，等待Client确认握手
* 第三次握手：Client将ack置1，如果Server接收到的包中ack序号正确，说明链接建立成功，双方进入estableshed状态。开始收发数据。

为什么是三次握手，而不是两次？可否四次？
网络传输过程中存在一个必然矛盾，安全性和传输效率。如果想建立一个稳定可靠的链接，三次握手是必然的。两次握手的弊端：
* 可能会出现已失效的连接请求报文段又传到了服务器端：假如Client发送第一次握手的syn包时发生了延迟，而后Client因为迟迟收不到第二次握手的syn包，那就超时重传，再次发送一个syn包。这样建立了一个链接。如果之前建立的syn包再次送达Server时，Server会进入syn_rcvd状态一直等待Client的第三次握手。可是Client永远不会和它进行第三次握手。这就造成了网络堵塞
* 两次握手只验证了Client到Server的seq序号，没有验证Server到Client的seq序号。
可以四次握手，但是就是降低了效率。四次握手中，Server确认Client的seq序号的返回包和Server发送seq初始序号的包合并就是三次握手中的第二次握手了。

第三次握手如果Server没有接收到Client的包：
Server就会认为自己发送的第二次握手的syn包没有发送成功，超时重传，最多重传五次，重传五次还不成功，那就关闭链接进入CLOSED状态。

已经建立链接，但是客户端出现故障，怎么办？
服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

四次挥手
同样省略了seq和ack序号的部分
四次挥手过程中Client和Server的控制位和状态变化：
* Client将Fin置1，客户端已经发送完全部数据，进入FIN_WAIT_1状态
* Server接收到FIN包后，返回第二次挥手，进入CLOSE_WAIT状态
* Server将Fin置1，进入LAST_ACK状态
* Client接收到FIN包后，发送第四次握手包，进入TIME_WAIT状态，等待2*MSL（报文段最长寿命）后关闭链接进入CLOSED状态。而Server接收后，也进入CLOSED状态。
这里为什么第二次和第三次挥手不能合并成一个呢？
因为Server接收到Client发送的FIN包后，第三次挥手之前，Server并不一定发送完了全部的数据。这时候只是Client发送完了全部数据。                                                                                                                                                                                           
TIME_WAIT状态是干嘛的？
Client结束到FIN包后，发送给Server的包可能会丢失，如果丢失，Server就会重发FIN包。TIME_WAIT就是为了等待这个可能会重发的包。

MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。
TCP如何实现流量控制（窗口控制）？

使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。
如果窗口为0时会怎样？
如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。
TCP的拥塞控制是怎么实现的？

拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）
1. 慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍
2. 拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.
3. 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
4. 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。



TCP与UDP的区别


1. TCP是面向连接的，UDP是无连接的；
2. TCP是可靠的，UDP不可靠；UDP接收方收到报文后，不需要给出任何确认
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
4. TCP是面向字节流的，UDP是面向报文的；
5. TCP首部开销（20字节）比UDP首部开销（8字节）要大
6. TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；
7. UDP 的主机不需要维持复杂的连接状态表

什么时候选择UDP

对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失。
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠
https://blog.csdn.net/yjxsdzx/article/details/71937886
这个博文应该看一下，感觉说的非常好

TCP如何保证传输的可靠性

1. 数据包校验
2. 对失序数据包重新排序（TCP报文具有序列号）
3. 丢弃重复数据
4. 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
5. 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
6. 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出









TCP协议模型四层



1.应用程序（浏览器邮件服务器等调用socket库）
2.协议栈 TCP（需要连接）  UDP（不要连接）  IP（传输网络包，确定路由）
3.网卡驱动程序（控制网卡）
4.硬件（网卡）


2.3@TCP协议保证可靠性的三种方法
        -序列号、确认应答、超时重传
        -根据网络包平均往返时间调整 ACK 号等待时间（超时时间）：假如网络堵塞时，ACK号返回之前，我们需要设定一个ACK号的等待时间，超过这个时间后就重传。超时时间一般是动态调整的，先设置为ACK号返回所需的时间（2*RTT(报文段往返时间）+一个偏差值），如果ACK号返回变慢，延长等待时间，如果ACK号返回很快，那么逐渐缩短这个时间。


-UDP：DNS查询等收发比较短的数据。
UDP支持一对一，一对多，多对一，多对多的交互通信。
UDP是尽最大努力交付，不保证可靠交付。
UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。
UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。
UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）
TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。
若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

网络层
Session与Cookie的区别？

路由器属于哪一层？交换机属于哪一层？

什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？

IP地址的分类？

什么叫划分子网？

什么是ARP协议 (Address Resolution Protocol)？

什么是NAT (Network Address Translation, 网络地址转换)？


    -IP：将数据切分成一个一个网络包，ip负责将网络包发送给通讯对象
    IP层怎么知道报文该给哪个应用程序：根据端口区分；看ip头中的协议标识字段，17是udp，6是tcp


    电信号传输TCP/IP数据：TCP/IP、套接字、协议栈、IP地址（网络中主机的逻辑地址）、端口号、 包、头部、网卡、网卡驱动、MAC地址（硬件地址，用来定位网络设备的位置）、 以太网控制器、ICMP、UDP

网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。

3.网卡驱动
    网卡将包转换为电信号并通过网线发送出去。

物理层
4.集线器、交换机、路由器
    网卡发送的包经过交换机等设备到达接入互联网的路由器
    假设客户端计算机连接家庭局域网络->通过ADSL和光线到户FTTH等宽带线路->互联网
    (1)路由器根据目标地址判断下一个路由器的位置
      (2)集线器在子网中将网络包传输到下一个路由

5.接入网、网络运营商
    由客户端连接的路由器到达运营商的路由器（互联网）
    互联网由很多运营商和大量路由器组成，网络发送的包就是在互联网上经过路由器接力，最终发送到目标web服务器上。

6.防火墙、缓存服务器
    在通过骨干互联网后，包到达web服务器所在的局域网中。
    防火墙对所有包检查。
    如果访问的网页数据在缓存服务器存在，直接从缓存服务器读取数据。如果不存在，请求web服务器。
    防火墙、包过滤、数据中心、轮询、负载均衡器、 缓存服务器、代理、代理服务器、内容分发服务、 重定向

7.web服务器
    网络包到达web服务器后，数据被解包为原始的请求。web服务器程序分析请求含义，执行操作。
    响应消息、多任务、多线程、虚拟目录、CGI、 表单、访问控制、密码、数据格式、MIME




阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。


同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步

### 系统启动的过程

以X86机器为例，回顾下系统的启动全过程

1. 开机后BIOS程序
  * BIOS是一段保存在主板上一块ROM芯片上的简单程序
  * BIOS将进行一些硬件检查工作，然后加载磁盘上的引导程序
2. 引导程序
  * 引导程序保存在磁盘的第一个扇区，引导扇区。
  * 如果引导扇区的最后两个字节如果是0x55和0xAA，就说名这个引导扇区是有效的，BIOS将加载这个扇区的引导程序。我们制作启动盘的引导就是这样的。
  * 引导程序加载内核代码，通常内核代码将加载到1MB以上的内存空间。因为BIOS和引导程序是在16位模式下执行的，他们只能寻址到1MB以下空间。引导程序还要将x86的16位模式切换到32位模式。
3. 进入32位虚拟保护模式后的寻址方式
  * 16位下实模式的寻址方式是：段寄存器<<4+IP寄存器偏移量 = 物理地址
  * 32位虚拟保护模式下：段寄存器保存的是段描述符，段描述符中的16位用于指定段，ip寄存器的32位用于指定段内的偏移。
  * X86提供了 CS SS DS 和三个通用段寄存器
  * 段描述符由系统开发者保存在内存中的一张表中，GDT 全局描述符表。 GDT的位置由一个专门的寄存器GDTR保存。
  * 但是Linux和win都没有采用GDT分段这种方式。而是绕过分段，使用多级页表。
  * 绕过分段的方式是全部的段寄存器都指向相同的段地址范围，而32位的ip地址足够可以寻址0～4GB的空间了。这就是平坦模型，整个内存空间分为一段

4. 初始化中断
  * 内核启动就意味着适配于32位虚拟保护模式下的一些驱动程序同时加载到主存中了，我们可以使用这些外设，但是还有一些基本的初始化工作。
  * 中断相关初始化。系统的异常情况由中断服务函数处理，也就是说一旦系统执行指令发生的异常情况，将跳转到中断服务函数。
  * x86提供了256个中断，0～31号非屏蔽中断是不可屏蔽的中断。32~47（即由I/O 设备引起的中断）分配给屏蔽中断。但是0～47号中断都是interl规定好的，固定的。48~255 用来标识软中断，比如缺页异常
  * cpu每执行一条指令后，都会检查下NMI和INTR这两个中断管脚是否有中断信号。如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量。
  * 这么多的中断函数，系统将这些中断函数的地址保存在中断描述符表IDT中，和GDT一样，有一个专门的寄存器IDTR来保存IDT的位置。

5. 开启分页实现虚拟内存
  * 将物理内存按照4KB一页大小划分，某一页的起始地址和页的属性，如读写权限，是否加载在主存中等。这些属性由32bit的PTE page table entry 页表条目来描述
  * 保存PTE的数组，就是页表PT page table 映射4GB内存空间的页表将占用4MB空间。
  * 创建一个页目录PDT，用来保存多张页表的位置。
  * cr3寄存器保存了PDT的位置。
  * 寻址过程：虚拟地址/0x1000=页表序号。 页序号/1024就是页目录PDT中第几个条目。找到这个页目录条目中保存的的物理地址就是页表的地址。（虚拟地址/0x1000）/0x1000就是PTE序号。读取PTE的20bit物理地址左移12bit，就是物理地址了。
  * cr0寄存器的高位用来开启分页。
  * 创建分页时，是用了一个数组frames来记录当前页是否已经被分页了。
  * 我的项目中，开启分页后，首先初始化了16MB的空间。这也是内核页表映射的16MB。

6. 创建内核堆，实现内存的动态分配
  * 内核堆中的内存用一个链表来记录。
  * kmalloc函数用来开辟一个指定长度的区块，kfree用来释放区块。
  * 在堆中开辟区块时，我设定的堆起始地址是128MB。但是实际上它的物理地址应该是从16MB开始生长的。
  *

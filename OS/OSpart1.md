# 走一遍os-tutorial

## 第一部分：系统的启动

#### 第零节：安装虚拟机环境 qemu和nasm
  macos下的安装方法，在终端中执行指令：brew install qemu nasm

  qemu就是一个虚拟机，nasm是一个为可移植性与模块化而设计的一个80x86的汇编器。
  作者贴心的提示了别用xcode里的nasm，因为它在我们的这个教程中大部分情况下都不能正常使用，哎它不顶用啊。那我就要提示下了，你用homebrew安装的nasm肯定是在/usr/local/Cellar文件夹里。这是homebrew的包安装路径/usr/local/bin里的nasm就是Cellar里的nasm的快捷方式。而xcode里的nasm就是系统安装的软件了，它肯定是在usr/bin里。当然这个bin里好多也都是快捷方式，看它的原身就可以知道一般都在Frameworks这个系统文件夹里。

  好的，当我写完这两句唠叨的时候，我的qemu和nasm也安装完了。

#### 第一节：为系统启动创建引导程序

先了解下BIOS，这个在电脑启动的时候有时候会遇到，那个蓝屏的菜单。人家的全名是"Basic Input Output System"，是计算机主板上的一段程序。主要负责在系统启动前：

    加电检查电脑硬件是否正常，初始化设备参数。
    从启动磁盘的开始扇区加载引导程序启动操作系统。
    为系统提供IO设备操作支持，硬件中断处理。


那么我们来运行一下作者给我们的程序吧！

    首先cd到你的工程文件夹。
    比如我就是在文件夹：os-tutorial/01-bootsector-barebones

    编译汇编程序：nasm -f bin boot_sect_simple.asm -o boot_sect_simple.bin
    这样可以在01-bootsector-barebones/下看到一个二进制文件boot_sect_simple.bin
    接下来在qwmu上运行这个程序吧！
    这个段汇编代码将引导扇区填充了很多个0x00和一个0xAA55.
    随后就进入了死循环。

##### macos catalina用户的问题
如果你是macos用户，并且系统更新到了catalina，恭喜你中奖了！https://stackoverflow.com/questions/58318920/qemu-not-responding-after-upgrading-to-macos-catalina

brew为我们安装的qemu4.1版本的图形化显示方式和catalina不兼容。预计在即将推出的qemu4.2版本中会解决这个问题。上面那个连接里提到了一个解决方案，不要用brew安装的qemu，自己编译一遍。按照他的编译设置，qemu的界面依赖的是SDL，这个也许能解决吧。但是我选择关闭图形化显示～就加一个-nographic 的选项。所以执行指令是这样的：

    qemu-system-x86_64 -nographic boot_sect_simple.bin
    可以看到 "Booting from Hard Disk...".

    或者用-curses,是一个很简陋的在终端上实现的图形化界面的库。但是我们不涉及到图形化界面。

  实际上如果仅仅在qemu跑一个成熟的系统的话，我们也可以通过远程桌面的方式来显示，比如VNC和SPICE。但是这个教程中我们是从头开始，你可以理解为qemu目前的状态是一个没有系统的电脑主机，因为catalina的bug，我们连显示器都没法用了。现在是2020年5月12号，可能过两年qemu就会解决这个问题了。

退出qemu

    先control+a，然后释放这两个键，再按下x，就可以退出qemu了。
-------------
#### 第二节：在引导扇区打印hello
#### 第三节
    nasm -f bin boot_sect_memory_org.asm -o boot_sect_memory_org.bin
    nasm -f bin boot_sect_memory.asm -o boot_sect_memory.bin
    qemu-system-x86_64 -curses boot_sect_memory_org.bin
    qemu-system-x86_64 -curses boot_sect_memory.bin
    第四节
    nasm -f bin boot_sect_stack.asm -o boot_sect_stack.bin
    qemu-system-x86_64 -curses boot_sect_stack.bin
    第七节
    nasm -f bin boot_sect_main.asm -o boot_sect_main.bin
    qemu-system-x86_64 -curses boot_sect_main.bin

#### 第七节 让引导扇区从磁盘加载数据

#### 第八节
    nasm -f bin 32bit-print.asm -o 32bit-print.bin
    qemu-system-x86_64 -curses 32bit-print.bin
    第九节
    nasm -f bin 32bit-gdt.asm -o 32bit-gdt.bin
    qemu-system-x86_64 -curses 32bit-gdt.bin
    第十节
    nasm -f bin 32bit-main.asm -o 32bit-main.bin
    qemu-system-x86_64 -curses 32bit-main.bin

以上，我们利用BIOS加载引导程序，引导程序完成了从磁盘读取数据。
注意哦，这个教程里内核代码直接和引导程序放在一起了。

我们可以总结下系统工作的流程：

    1.bios启动加载引导扇区的引导程序bootsect.asm：。
    2.引导程序加载内核代码到内存中（本节中作者直接把内核代码和引导程序都放在引导扇区了，这样就省的重新写32位保护模式下的磁盘驱动了）。
    3.切换到32虚模式
    4.执行内核代码，现在我们还没有内核～～

在屏幕上打印字母。但是我们还没有真正构建起我们的系统内核。如果给以上章节一个类比，我觉的现在就相当于我们的电脑还没完成开机。哈哈其实就是这样，BIOS加载了引导扇区的程序后，通常会加载系统程序。但是我们加载的是读取磁盘和打印字母的程序。接下来就开始真正构建我们的内核吧。


#### 第十一节  终于摆脱了汇编，迎来高级语言
  从C语言开始，那么首先安装一个C语言编译器吧，就用gcc,作者提供的方式是下载源码自己编译源文件.
    https://github.com/cfenollosa/os-tutorial/tree/master/11-kernel-crosscompiler

  作者写这个教程已经是三年前了，现在其实可以直接用brew安装的

    brew tap nativeos/i386-elf-toolchain
    brew install i386-elf-binutils i386-elf-gcc
    好了我们把gcc编译器和配套工具集binutils安装完毕。

#### 第十二节   编译运行下C代码
  要通过这一节作者提供了几个非常简单的小栗子，我们编译一下试试看
    编译：

      i386-elf-gcc -ffreestanding -c function.c -o function.o
      这条指令的意思是，指定gcc编译器，将function.c这段c代码，转化成了可重定位目标文件function.o。
      但是这段代码没有main函数，所以要以ffreestanding形式编译。
      也就是说这段代码最后其实是没办法执行的，因为没有函数入口。
      这其中还包含三个过程：
        -首先C语言预处理器将源代码中的#命令（包含文件和宏定义）全部替换为对应的代码段。
        -然后编译器将生成源文件function.c的汇编代码function.s
        -接下来汇编器将汇编代码转换为function.o
        -可以利用反汇编器查看汇编代码：i386-elf-objdump -d function.o
  链接：

      i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o
      这样就得到了可执行的二进制文件function.bin

##### 本节咱们还要补充一些额外的知识。关于makefile文件的功能和作用

    如果你用过cmake，或者从源码安装过一些软件，肯定见到过makefile
    第一次用cmake已经是好几年前的事情啦，这个时候回忆往事真的感慨万千。好怀念本科的日子。
    那时候对cmake.. 和make这两个命令都不知道是干嘛的。
    就知道执行完就有了bin文件了，所以这两个命令打的飞快，感觉一秒钟就两条命令输入完成了哈哈。

##### makefile的作用

    上面我们在由源文件生成bin文件的时候，需要手动逐个文件编译。
    要是仅仅一个文件还好，要是在main函数中调用了好多个子函数呢。
    每一个源文件编译实在是太麻烦啦！
    所以项目管理工具make应运而生了，要是下载一个包的源代码。
    通常在文件夹里都会有一个makefile，make就是按照这个文件来编译链接源代码，生成可执行文件。
    然后我们再执行make install，就安装到了电脑到默认路径下。
    可见makefile就是make的药方，makefile告诉了make各个源文件之间的依赖关系。

##### camkelist

    你要是用过cmake，就一定记得camkelist，在cmakelist里配置项目依赖的库和生成文件路径什么的。
    就很简洁，虽然还是不如IDE方便。可是已经比makefile容易太多啦。
    cmake就是一个跨平台的项目管理工具，他把make的工作进一步抽象。
    cmake命令就是将cmakelist文件翻译成makefile的格式，所以camkelist相比makefile可读性也更高啦！

好了，我们cd到第十三节这个文件夹下，里面有一个makefile。是作者写好到，我们运行下make指令，是不是编译运行都一下全搞定了呢？对了，要是你和我一样是是macos catalina，记得修改下makefile，加上-curses这个选项。还有，makefile中中的gcc和gdb路径记得更改，如果是和我一样用homebrew安装的话。在第十三节中，我们就已经在虚拟器上运行了一段代码了。这是我们直接运行于硬件（虽然我们是在虚拟机上）上的代码。尽管它很简单，只能在屏幕上打印一个x出来。但是我们已经可以看到内核雏形了，不对，应该是看到了未来组成内核的核糖核苷酸吧。


#### 第十四节   创建一个简单的内核和一个能够引导它的引导程序

安装调试工具gdb

    作者提供的方法又是由源码安装，这个项目毕竟是三年前的了。
    如今brew里已经有gdb了，所以直接用brew安装gdb就ojbk～

跑下本节代码

    首先make，得到os-image.bin
    然后运行下：qemu-system-i386 -curses -fda os-image.bin
    但是打开makefile看下代码你就会发现，哎，make run 和 make debug这个两个命令也有哦
    make run就是直接编译链接后运行bin文件了，
    make debug 就是以debug模式运行，但是macos目前和qemu的冲突，实际上没办法正常调试～
    curses模式下，你试下就知道发生什么了哈哈。
    在-nographic模式下，还可以。


现在看来我们的内核还有模有样了，通过BIOS加载的引导程序，载入内核代码到内存中，内核代码运行就相当于我们的系统跑起来啦！

本节中，内核代码的main函数在链接时，手动指定了代码段的内存地址，因为代码实在太简单了，只有一个main。所以加载到内存中的代码段的第一条指令肯定是main。
如果我们的工程非常庞大复杂的时候，可能在main之前会声明很多全局变量，或者宏定义，或者包含文件，而且这些代码可能还会更新。那么内核代码的main在代码段的地址就无法预测了。所以系统一般都会将一个非常简单的函数始终放在整个内核代码的开头，它的唯一作用就是调用内核的入口函数。在链接的时候会被连接器放到整个工程代码到最开始。

实际上我发现不只是系统，我们使用的任何框架一般也都是这样，比如我MFC框架下我们看不到显式的main，ios开发时的工程中你也看不到显式的main。但是他们肯定会有一个非常简单的函数，在链接的时候加载到代码段的最开始位置。另外我还想到，在C++或者其他面向对象语言中，即使是一个简单的工程，也不一定是从main开始执行的。比如说我们在main之前实例化一个类，那么是不是它的构造函数要先执行呢？所以在main之前包含的文件也有可能是项目执行的起点。


------

### 1.基础知识
  计算机中使用0和1二进制，这个原因没得说。我们使用十六进制方便表达和理解二进制。
  字长（word size），指明指针的范围，决定了系统可访问的虚拟内存的地址范围。
  32位系统地址空间是0～2^32-1，正好是4GB。
### 2.i386的16位模式和32位模式（关键要知道32位模式下如何寻址的，我认为非常重要）
#### 为什么要了解两种寻址模式？

Intel称其为虚拟地址保护模式完全是历史问题。

8080、8085 ：8位芯片，地址总线都是16根，寻址2^16=64K

8086、80186：16位芯片，地址总线是20根，寻址2^20=1M

80286、80386：32位芯片，地址总线为32根，寻址2^32=4GB
（但是段寄存器还是16位的，好多博客都写错了，不要被带跑偏）

因为之前的产品只支持16位寻址，而且对应实际的地址线，所以称其为实模式。而80386这些产品为了兼容之前的产品，就搞出了双模式。这样8086的程序在80386上也可以运行。

在更大的空间下，我们需要一种机制对内存的访问做些限制，比如用户级代码不能随意访问内核代码段。如果我们有多进程，那还要对进程间的内存访问做一些限制。从这里开始，我们才有了在芯片上植入操作系统的条件和需求。毕竟，之前的1M内存，谈什么内存管理，还要什么系统呀。

我们还要明确的是，在80386这种机器上，反正硬件上是32位寄存器，地址线是32根。至于怎么实现内存管理，那是操作系统需要给出的方案，而不同的操作系统可能实现上有所区别。比如win就不用GDT，Linux中基本不使用LDT。非intel的芯片就直接线性寻址，而intel就采用分段的地址空间。

但是我们不需要管那些东西，只需要知道这个教程是如何实现的就可以了。不管如何实现，在我们继续丰富操作系统的虚拟内存的时候，我们的程序总是可以给出一个唯一的寻址方式。这不就足够了吗？CSAPP里讲虚拟内存的时候，是以Linux为例讲的。但是我们还不一定完全按照Linux来实现呢。

我总是感觉应对这些历史遗留问题非常无聊，可是发展的看待这个问题，或许10，20年后的人再看目前的64位机器，也会想我一样有这种心态。技术总是飞速发展的，后来者总会站在前人的肩膀上眺望更远的地方。我们目前能够使用以前的开发者无法想象的8G，16G，甚至更大的内存空间，也要多亏了之前的技术积累。

在我们开发过程中，也许会遇到类似的问题，当索引一个非常大的数组的时候，如果数组的长度已经超过了long long可表达的范围时，你会怎么做呢？我们可以将数组分段，那就变成了一个二维数组了。随机我就联想到另一个数据结构deque的实现。而这些又和虚拟地址的分段分页好像呀。

#### 16位实模式：
    8086的地址线有20根，可寻址范围是0～2^20-1，也就是1M字节。
    但是它的寄存器都是16位，所以只能直接访问2^16个字节，也就是64k。
    但是可以通过两个寄存器范围1M范围：段寄存器<<4+IP寄存器偏移量 = 物理地址

#### 32位保护模式（虚拟地址保护模式）

32位保护模式下，有32根地址线，那么就可以对2^32=4GB大小的空间寻址了。

段描述符(Segment Descriptor，8个字节)来描述某一个内存段。

    用来描述内存分段的Base Address基址，Limit段长限制，各种段解释标志位。

    例如描述符类型标志S表示段描述符是系统段描述符（当S=0）还是代码或数据段描述符（当S=1）。
    描述符特权级字段DPL（Descriptor privilege level）：用于指明描述符的特权级。特权级范围从0到3。0级特权级最高，3级最低。DPL用于控制对段的访问
    段存在标志P（Segment present）：用于指出一个段是在内存中（P=1）还是不在内存中（P=0）。当一个段描述符的P标志为0时，那么把指向这个段描述符的选择符加载进段寄存器将导致产生一个段不存在异常。
    这就和后续的缺页异常联系起来了呀。

    每一位具体的含义就是系统开发者决定的，我们也可以不这样做，硬件上没有限制的。
    那我现在给出的段描述符的解释是谁来决定的？当然是intel了。
    段描述符的更细致的解释，我想还是看这个图吧，感觉更容易理解。图的来源https://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf 这个文档里对应的那个图4.2
GDT全局描述符表：是一个段描述符数组，保存在主存中。

    这个位置也是由系统开发者决定的，但是一定是在主存的前1M空间内。
    因为我们是在16位实模式下启动的。在系统启动前，就要将GDT分配好。
    实模式下只能寻址1M空间。当然进入虚模式后，你也可以将GDT移动到其他位置。

LDT局部描述符表：是一个局部段描述符数组，但是是属于局部的，某一个任务的。

GDTR寄存器：

    专门保存GDT全局描述符表的位置。因为硬件上对GDT的位置没有规定，所以不同的系统可以将GDT放在不同的位置。
    为啥非得有一个

段寄存器寻址方式为：

    CS是代码段，DS是数据段，SS是堆栈段，ES是附加段。
    16bit的段寄存器的高13bit中存放GDT的索引，CPU根据这个索引找到GDT中的段描述符。
    低3bit分别是：
        1bit的TI（Table Indicator）位是引用描述符表指示位，TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
        最低2bit是请求特权级RPL(Requested Privilege Level)，用于特权检查。CS和SS寄存器中的RPL就是CPL（current privilege level当前特权级）Linux下使用0、3两个别人是内核态、用户态。
    每个段寄存器还有一个32bit的对应的高速缓存寄存器，也就是很多博客说的隐藏字段。这隐藏的64bit就是缓存完整的段描述符的。

    段寄存器>>3 + IP寄存器 = 线性地址。

几乎所有的博客在介绍虚拟地址保护模式的时候都会提到分段的问题，分段这是实模式下的名词，因为采用的是段地址+基地址的寻址方式。而到了32位时代，EIP指令寄存器已经是32位了，可以直接访问到4GB空间。那也无所谓分段了。绕过分段的方式是给出的基地址是0就可以了。我感觉我们就不要提分段这个词好了。无所谓分不分段。

这这一部分，关于GDT的寻址模式，我开始总是会和系统的虚拟内存实现方式混淆。总感觉他们是不是在做同一件事情啊。但是想到一个问题我就明白了，不管我们怎么对内存做映射，都还没有涉及到主存和磁盘的数据交换。所以GDT看起来的功能好像和页表类似，但是页表是更高级的抽象了，当我们完成了对硬件的寻址后，给系统提供了一个寻址方式。对它来讲这个寻址就是对4G空间的映射。而虚拟内存，是想在此基础上，给出一个更加高效对内存利用方式。后面的内容，我们在Part4见吧。

我们使用32位模式的时候，有了一些变化

    可以访问更大范围大内存地址了，最高可以到4G。
    地址保护模式将内存分割位一个个片段，我们就可以对特殊的内存地址进行保护了。
    实际上在这个时候我们就可以根据GDT对访问对地址做一些限制了。比如内核代码所在的地址，我们不希望被用户代码访问。
    还有，因为bios的代码都是在16位实模式下写的，32位模式下内存访问方式变了，所以bios的代码都不能使用了。
    那么就需要我们自己实现对硬件的管理，也就是要重新实现硬件的驱动程序。

### 3.x86的内存地址
首先，GPU访问一切外设都是根据物理地址（这句话是我说的，暂时感觉没毛病）。既然在32为虚拟保护模式下，可以访问4GB内存空间，除了分配给主存还有一些地址要分配给特定的外设。比如BIOS所在的ROM0xFFFFFFF0，显存0xb8000，键盘等。但是x86没有直接采用统一端口编址，还有些外设是独立端口编址，要用IN/OUT指令访问。  比如显卡的某些寄存器。


### 4.处理器运行程序的过程
  尽管我们只是运行了一个非常简单的汇编程序。首先将它编译成二进制可执行文件。然后BIOS将它加载到内存中固定的代码段。处理器就会不断的执行程序计数器指向的指令，在更新程序计数器，指向下一条指令。这个过程中，处理器做的工作非常简单。只有几个操作：

    加载：从内存赋值一个字节到寄存器
    存储：从寄存器赋值一个字节到主存
    操作：把两个寄存器的内容复制到算数逻辑单元ALU进行计算，将结果放到一个寄存器中。
    跳转：从指令中抽取一个字，复制到程序计数器中，覆盖掉原来的值。
一旦我们开机，有程序在运行，那么cup就会无休止的重复这几个操作。操作系统和其他硬件对他来讲都是另一个世界的人。它就像一头蒙上了眼睛的驴，无休止的拉磨盘，好可怜～看来cpu也是很简单的嘛。但是cpu背后有一套复杂的机制来实现高速运行。


### 5.计算机的启动过程
主板电压稳定后，主板上控制芯片向CPU发送到reset信号会被撤销，CPU就开始工作了。CPU从开始工作，它的工作内容就是固定的：取指令-翻译指令-执行，循环往复。它的第一条指令的地址是0xFFFFFFF0也就是BIOS所在的地址。BIOS会执行一些硬件检测，最重要的，它要加载操作系统。

如果你安装过系统，记不记得用优盘安装的时候会更改下启动方式，从优盘启动还是从磁盘启动。这就是选择BIOS加载的引导程序在哪里。引导扇区要引导加载内核程序，非常重要。因此，引导扇区必须放置在已知的标准位置。该位置是磁盘的第一个扇区（柱面0，磁头0，扇区0），占用512字节。放在这里的好处就是好找，就在磁盘开头嘛。但是磁盘不一定在引导扇区存储着引导程序。所以我们需要做下标记，告诉BIOS这个磁盘是有bootloader引导程序的。BIOS检查引导扇区的最后两个字节是不是0xAA55。如果是，那这个引导扇区就是有效的。随后引导程序被加载到内存的0x7C00地址处，并且跳转过去执行。


#### 6.我们可以借此回忆一下程序的运行过程。

    源代码->
      预处理：处理全部包含文件和宏定义代码段，得到.i文件
      编译：词法分析，语义分析，代码优化，得到.s文件
      汇编：得到汇编文件.o
      链接：将源代码用到的库和各种依赖整合在一起，最终才能生成一个完整的可执行文件。

#### 7.链接器的作用

  在开发中非常重要，但是我在应用层面上很少去了解它的工作。他的作用是将开发人员用到的代码和数据片段整合在一起。

  链接可以执行于编译时：

      静态链接库，我们的项目中用到的各种lib文件就是静态链接方式加入到项目中的。
      它的缺点就是，我们需要的库目标文件在项目中每出现一次，就会生成一个.o文件。
      这样加载到内存代码段的代码就变多了。但是静态链接方式的程序运行速度快。

  也可以执行于加载时：

  也可以执行于运行时：

      dll动态链接，项目中依赖的库函数，在运行时，才将库函数和开发代码（机器码）链接起来。
      这样运行速度慢了一些，可是项目的代码段小了很多。

      我发现在继续完成这个项目的时候，还是要自己写makefile，所以总结下makefile的语法和使用方法。在这里：
#### [使用makefile](https://github.com/isyiming/live-up/blob/master/Reading&thinking/makefile.md)




#### 8.程序运行时的内存分配和程序入口

许多操作系统正确输入内核的一个技巧是编写一个非常简单的程序集例程，该例程始终附加到内核机器代码的开头，其唯一目的是调用内核的入口函数。
之所以使用汇编，是因为我们确切地知道它将如何在机器代码中翻译，因此我们可以确保第一条指令最终会导致到达内核的入口函数。

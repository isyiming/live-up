## 第二部分：从简单程序迈向操作系统


#### 第十一节  终于摆脱了汇编，迎来高级语言
    从C语言开始，那么首先安装一个C语言编译器吧，就用gcc,作者提供的方式是下载源码自己编译源文件.
    https://github.com/cfenollosa/os-tutorial/tree/master/11-kernel-crosscompiler

    其实可以用brew安装的
    brew tap nativeos/i386-elf-toolchain
    brew install i386-elf-binutils i386-elf-gcc
    好了我们把gcc编译器和配套工具集binutils安装完毕。

#### 第十二节   编译运行下C代码
    开始编写内核，从这部分开始，我们来到了CSAPP的第二部分。
    要通过这一节作者提供了几个非常简单的小栗子，我们编译一下试试看
    编译：
      i386-elf-gcc -ffreestanding -c function.c -o function.o
      这条指令的意思是，指定gcc编译器，将function.c这段c代码，转化成了可重定位目标文件function.o。但是这段代码没有main函数，所以要以ffreestanding形式编译。也就是说这段代码最后其实是没办法执行的，因为没有函数入口。
      这其中还包含三个过程：
        -首先C语言预处理器将源代码中的#命令（包含文件和宏定义）全部替换为对应的代码段。
        -然后编译器将生成源文件function.c的汇编代码function.s
        -接下来汇编器将汇编代码转换为function.o
        -可以利用反汇编器查看汇编代码：i386-elf-objdump -d function.o
    链接：
      i386-elf-ld -o function.bin -Ttext 0x0 --oformat binary function.o
      这样就得到了可执行的二进制文件function.bin


##### 本节咱们还要补充一些额外的知识。关于makefile文件的功能和作用

    如果你用过cmake，或者从源码安装过一些软件，肯定见到过makefile
    第一次用cmake已经是好几年前的事情啦，这个时候回忆往事真的感慨万千。好怀念本科的日子。
    那时候对cmake.. 和make这两个命令都不知道是干嘛的。
    就知道执行完就有了bin文件了，所以这两个命令打的飞快，感觉一秒钟就两条命令输入完成了哈哈。

##### makefile的作用

    上面我们在由源文件生成bin文件的时候，需要手动逐个文件编译。
    要是仅仅一个文件还好，要是在main函数中调用了好多个子函数呢。
    每一个源文件编译实在是太麻烦啦！
    所以项目管理工具make应运而生了，要是下载一个包的源代码，通常在文件夹里都会有一个makefile，make就是按照这个文件来编译链接源代码，生成可执行文件。然后我们再执行make install，就安装到了电脑到默认路径下。
    可见makefile就是make的药方，makefile告诉了make各个源文件之间的依赖关系。

##### camkelist

    你要是用过cmake，就一定记得camkelist，在cmakelist里配置项目依赖的库和生成文件路径什么的，就很简洁，虽然还是不如IDE方便。可是已经比makefile容易太多啦。
    cmake就是一个跨平台的项目管理工具，他把make的工作进一步抽象，cmake命令就是将cmakelist文件翻译成makefile的格式，所以camkelist相比makefile可读性也更高啦！
好了，我们cd到第十三节这个文件夹下，里面有一个makefile，是作者写好到，我们运行下make指令，是不是编译运行都一下全搞定了呢？
对了，要是你和我一样是是macos catalina，记得修改下makefile，加上-curses这个选项哈。还有，makefile中中的gcc和gdb路径记得更改，如果你是和我一样用homebrew安装的话。


在第十三节中，我们就已经在虚拟器上运行了一段代码了。这一步相当于什么呢，感觉就像在单片机上运行了一段程序，就好比点亮小灯。这是我们直接运行于硬件（虽然我们是在虚拟机上）上的代码。尽管它很简单，只能在屏幕上打印一个x出来。但是我们已经可以看到内核雏形了，不对，应该是看到了未来组成内核的核糖核苷酸吧。我们再努力下，让他早日变成受精卵。


#### 第十四节   创建一个简单的内核和一个能够引导它的引导程序

安装调试工具gdb

    作者提供的方法又是由源码安装。这个项目毕竟是三年前的了，如今brew里已经有gdb了。所以直接用brew安装gdb就ojbk～

跑下本节代码

    首先make，得到os-image.bin
    然后运行下：qemu-system-i386 -curses -fda os-image.bin
    但是打开makefile看下代码你就会发现，哎，make run 和 make debug这个两个命令也有哦
    make run就是直接编译链接后运行bin文件了，
    make debug 就是以debug模式运行，这要多亏我gdb～


我们可以总结下系统工作的流程：

    1.bios启动加载引导扇区的引导程序bootsect.asm：。
    2.引导程序加载内核代码到内存中（本节中作者直接把内核代码和引导程序都放在引导扇区了，这样就省的重新写32位保护模式下的磁盘驱动了）。
    3.切换到32虚模式
    4.执行内核代码

现在看来我们的内核还有模有样了，通过BIOS加载的引导程序，载入内核代码到内存中，内核代码运行就相当于我们的系统跑起来啦！


本节中，内核代码的main函数在链接时，手动指定了代码段的内存地址，因为代码实在太简单了，只有一个main。所以加载到内存中的代码段的第一条指令肯定是main。
如果我们的工程非常庞大复杂的时候，可能在main之前会声明很多全局变量，或者宏定义，或者包含文件，而且这些代码可能还会更新。那么内核代码的main在代码段的地址就无法预测了。所以系统一般都会将一个非常简单的函数始终放在整个内核代码的开头，它的唯一作用就是调用内核的入口函数。在链接的时候会被连接器放到整个工程代码到最开始。

实际上我发现不只是系统，我们使用的任何框架一般也都是这样，比如我MFC框架下我们看不到显式的main，ios开发时的工程中你也看不到显式的main。但是他们肯定会有一个非常简单的函数，在链接的时候加载到代码段的最开始位置。

另外我还想到，在C++或者其他面向对象语言中，即使是一个简单的工程，也不一定是从main开始执行的。比如说我们在main之前实例化一个类，那么是不是它的构造函数要先执行呢？所以在main之前包含的文件也有可能是项目执行的起点。

#### 第十五节   使用VGA端口
#### 第十六节   视频显示驱动
#### 第十七节   滚动显示支持

5.14日伤心日，昨晚写的这里的竟然还没提交就没了。应该是我不小心复制文件的时候覆盖掉了。

我们再来看下项目的文件结构吧

    一个boot文件夹：
      这个在win系统下就有哦，win系统里有一些字体，还有efi那是引导文件。
      作者在这个文件夹下放了print、bootset、disk、gdt、等等。
      任何和引导相关的文件都放在这里，
    一个kernel文件夹：
      这个就是我们系统的内核啦，但是它还没有发育起来。
    还有一个驱动程序文件夹：
      在进入32位模式下工作后，bios就完全不能用了，而且本来bios支持的硬件也很少。
      所以要有新的驱动程序，在系统启动后能够正常驱动硬件。

以上三节都是想要实现一个看起来非常基础都功能，就是在屏幕上正确显示字符，而不是像之前那样仅仅在屏幕左上角显示一个字母。回顾一下系统的概念，系统是对硬件的抽象。它将为上层的应用提供统一的接口。这三节就是这个抽象的过程。我们是要对屏幕进行操作，我们要将内存中的数据发送给显示设备，这就是我们要实现的第一种I/O。

实际上系统要做的工作也没有太复杂，因为屏幕这个硬件的具体显示我们不需要管。只需要将要显示的数据不断的发送给设备控制器。但是CPU的运行速度远远快于显示设备的处理速度。如果我们想播放一段视频，cpu将一帧数据，cpu可以很快将这件事做完。但是这个时候显示设备还没处理完这些数据，那么cpu就需要等待。宝贵的CPU时间段都用来等待未免有些浪费了。所以就有了DMA，专门处理这种高速和低速设备之间的数据传输问题，把CPU解放出来。不过这个教程中没有使用DMA。


那么来看下drivers/screen.h吧
```C++
#define VIDEO_ADDRESS 0xb8000 //定义了视频地址 这里我是不确定的
#define MAX_ROWS 25 //行数
#define MAX_COLS 80//列数
#define WHITE_ON_BLACK 0x0f//默认颜色方案
#define RED_ON_WHITE 0xf4

/* Screen i/o ports */
#define REG_SCREEN_CTRL 0x3d4
#define REG_SCREEN_DATA 0x3d5

/* Public kernel API */
void clear_screen();
void kprint_at(char *message, int col, int row);
void kprint(char *message);

```
三个函数分别是清屏、在特定的位置显示一个字符串、直接显示一个字符串。

这三个函数的基础是，如何在屏幕上显示一个字符print_char()。

    视频存储器是bios程序在系统启动之间，就将其地址写入到设备控制器中了。
    视频存储器的每个字符第一个字节是字符的ASCII码，第二个字符是我们的配色方案。
    我们想要做的就是不断的将想要显示的字符或图案数据发送给视频存储器。
    例如，想要在第3行第4列显示一个字符。
    那就需要将视频存储器的第488((3*80+4) * 2)个存储单元的，
    第一个字节填入想要显示的字符的ASCII码，第二个字节填入想要的配色方案。

那么清屏：

    就显示满屏幕的空白字符就好了。

屏幕滚动的实现：

    如果显示的时候已经到最后一行了，就需要滚动显示。
    就将视频存储器的某一行数据复制到上一行的地址空间就好了。
    这里作者写了一个函数util.c。
    这个可能会在其他地方也使用到，所以这个函数就放在kernel文件夹下啦。
    clear_screen()就是调用的util.c。

现在看来我们的内核已经可以做些事情了，我们完成了一个最基本的I/O的抽象。现在我们的系统上任何新的程序想要在屏幕上显示字符的话，只需要kprint_at或者kprint就好啦。

显然这个系统还是太简陋了，而且我们知道，Linux系统的一个基本特征就是，设备将被抽象为文件I/O。磁盘，鼠标，键盘，屏幕等都可以用一个统一的接口来调用。
而且，我们的系统还不具备异常情况的处理，比如说如果突然显示器和主机断开连接了，我们没办法访问视频存储器了。现在我们的系统，可能出现一个错误，系统就挂掉了，这显然不是我们想要的。
另外，处理键盘的输入，现有的内核代码会怎样处理呢？我们只能在程序中写一个死循环，不断的检测键盘是否有按键按下，然后输出字符。这样显然效率太低了。cpu除了这件事什么都做不了了。
所以，要考虑到各种异常情况，在有可能的情况下，尽量保证系统出现异常时能给出解决方法，不要出点情况就崩溃。

---------

#### 3.我们可以借此回忆一下程序的运行过程。

    源代码->
      预处理：处理全部包含文件和宏定义代码段，得到.i文件
      编译：词法分析，语义分析，代码优化，得到.s文件
      汇编：得到汇编文件.o
      链接：将源代码用到的库和各种依赖整合在一起，最终才能生成一个完整的可执行文件。

#### 4.链接器的作用

    在开发中非常重要，但是我们在应用层面上很少去了解它的工作。他的作用是将开发人员用到的代码和数据片段整合在一起，
    链接可以执行于编译时：
      静态链接库，我们的项目中用到的各种lib文件就是静态链接方式加入到项目中的。
      它的缺点就是，我们需要的库目标文件在项目中每出现一次，就会生成一个.o文件。
      这样加载到内存代码段的代码就变多了。但是静态链接方式的程序运行速度快。
    也可以执行于加载时：
    也可以执行于运行时：
      dll动态链接，项目中依赖的库函数，在运行时，才将库函数和开发代码（机器码）链接起来。
      这样运行速度慢了一些，可是项目的代码段小了很多。


#### 5.程序运行时的内存分配和程序入口

许多操作系统正确输入内核的一个技巧是编写一个非常简单的程序集例程，该例程始终附加到内核机器代码的开头，其唯一目的是调用内核的入口函数。之所以使用汇编，是因为我们确切地知道它将如何在机器代码中翻译，因此我们可以确保第一条指令最终会导致到达内核的入口函数。

#### 5.既然出现啦kernel，我们就要说下系统是干嘛的了。
    在本节之前，我们在计算机只跑了一个程序。程序运行开始就代表了系统工作，程序结束，系统也就下班了。
    设想下我们现在有两个需求，一个是在网络上爬取历年各国的gdp数据保存到硬盘上。
    另一个是读取硬盘中的gdp数据分析下2020年那个国家的经济最先崩盘，按照可能性制成一张表，也保存在硬盘上。
    哎，访问网络、数据写入硬盘、读取硬盘数据，这些功能要是都一个一个的写程序，好麻烦。
    对，这是面向过程的编程，作为一个现代程序猿，我们应该面向对象了。
    那么，我们需要对硬件访问做一个封装，让它来为我们的上层应用提供通用的抽象的接口。
    哎呀，就这么轻易的将语言的知识和操作系统结合起来了，我真是一个善于总结的小能手。
    kernel，是一个操作系统的核心。
    它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，后续它应该可以提供给我们中多系统调用方式。

#### 6.操作系统管理硬件
    操作系统的两个作用：
      防止硬件被失控应用程序滥用
      想应用程序提供简单一致的机制来运行硬件设施
    实现的方法就是：
      将硬件设施和接口抽象几个基本概念：
      进程：系统分配资源的最小单位，进程包括了处理器时间片段，虚拟内存，文件等系统资源
      虚拟内存：主存和文件的抽象（磁盘等一切IO设备都可以认为是文件）
      文件：将各种IO设备抽象为一个统一的概念

#### 4.设备控制器
#### 4.dma

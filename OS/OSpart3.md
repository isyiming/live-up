## 第三部分：逐步完善的系统内核
-------------

#### 第十八节   中断
#### 第十九节   中断请求irqs
#### 第二十节   定时器
#### 第二十一节   shell


在第二部分，我们终于引导内核启动了，并且完成了第一个外设，屏幕的驱动。由于第二部分涉及到了很多字符串操作，这些操作在系统中可能非常常见，其他模块也会用到。那么我们就可以将这些字符串操作函数放在一个libc文件夹下。作为我们系统提供的库文件。

第三部分的工作就是新的外设：键盘输入。但是和屏幕不同，我们希望cpu接收到一个触发信号后才响应，平时它就干自己的活。这次cpu是从外设接收信号，所以需要cpu提供中断的功能。然后还实现了cpu计时器的功能。这两个功能的实现其实在系统中不经常被提到，因为不同的硬件可能具体实现不太一样。

关于中断和系统异常处理的知识放在文档最后总结吧。实际上我发现很多系统的教材，中断的实现这一块其实很少内容。这一部分的实现原理，好像对我们了解内存的分配，并发等没什么帮助似的，确实如此哈哈哈，反正我感觉确实没什么用。但是准备在这个教程的基础上继续添加功能呢，既然看到这里了，索性就把它看完吧。


我们首先分析下工程的文件吧

    boot/
      这个一般不会变了
    kernel/
      kernel.c  main()
      util.c util.h
          int_to_ascii()和memory_copy()
          memory_set()功能是将指定内存空间填入指定的值。
          reverse() 翻转数组
          strlen() 返回数组长度
    cpu/
        types.h 定义了一些类似于 unsigned int之类的变量类型
        isr.c 触发中断后，isr_handler将消息和中断号输出到屏幕上
        isr.h中定义了中断向量表，一共有32个中断向量
        interrupt.asm是真正执行触发中断后的中断处理函数的
        idt.h中定义了中断向量的数据结构
        timer.h init_timer cpu计时器初始化函数，会调用中断处理函数register_interrupt_handler，定时中断触发后就执行timer_callback打印当前的系统时钟。
    drivers/
      ports和screen是屏幕的驱动
      keyboard 键盘的驱动 实际上这个键盘的驱动还是有点问题，shift+输出的特殊字符都没办法正常显示，比如一个%，会显示成?5。但是我还是想先不管他了。
    libc/
      string.c 将一些字符串处理用到的函数放在这里。

从这里开始我们能明显的感受到系统代码的丰富，而且它越来越接近我们日常的使用逻辑了。

首先boot这种非常底层的，在系统启动之前运行的代码，我们后面几乎不会碰到它。正如我们平时做应用层面的开发工作，几乎没有和系统的底层打交道。而boot对于系统而言也是非常底层的存在了，它运行在系统启动之前嘛。

在cpu这个文件夹下，我们实现了非常重要的功能，就是中断处理函数和cpu时钟（其实也是中断）。这个就是系统异常控制的基础。在完成了这部分内容后，我们好像也不会再改动这部分内容了，我指的是中断的实现。但是后续添加更多的异常控制，会增加中断处理函数。

而drivers呢，全部是我们的系统外设的驱动。一旦一个新的外设添加后，写好它的驱动程序，也不会再更改了。我想目前的两个外设：屏幕和键盘。已经足够了，我们没有实现图像化界面的计划。

kernel这个文件夹是内核的核心，也是系统逻辑的主干。实现更具体的内核功能都要在这里开始。

libc这里将存放我们认为是有需要作为系统提供的可调用函数库。


中断这个逻辑虽然比较容易懂，但是中断具体在CPU内部如何实现的，CPU怎么就跳转到中断处理函数了呢？这个细节在这么多的概念中就不那么清晰了。

我们还是来回顾一下一个中断触发的过程吧～

idt.h中给出了中断描述符的数据结构，并且给出初始化中断向量的函数。
在isr.c中提供了初始化中断向量表的方法，如果你想更改系统的中断（你应该不会更改0～47号的中断功能），就在这里更改。

    系统启动的时候,在kernel里，
    1. 执行isr_install()。isr_install()调用以下三个函数：
        1) 调用set_idt_gate()逐条设置中断描述符表IDT，将它保存在主存中。
        2) 调用port_byte_out()初始化PIC可编程中断控制器。哎，这个真的不想总结了，PIC在现代电脑中已经不再使用了。总之，是一个对这么多中断进行分级管理的芯片。
        3) 调用set_idt()初始化中断处理函数数组所在的地址。也就是0～31号中断。
    2. 执行irq_install()。这是初始化中断请求的地方。
        也就是开发者可以根据需要更改的地方。
        比如这个教程里，我们不是实现了两个中断嘛。
        一个是键盘触发的输入信号，一个是系统定时器。
        这两个都是在irq_install里初始化的。
    他们的触发都是先在isr_handler()或者irq_handler()里将handler置入对应的中断号的寄存器操作（通过registers_t这个数据结构实现），然后在register_interrupt_handler中调用到底执行那个中断处理函数。
    而具体的中断处理函数是汇编实现的interrupt.asm。但是他们都在isr.h有声明。


这里的编程方式真的读起来就感觉特别的古老，底层。执行不同的中断处理函数，调用不同的函数实际上是根据函数地址来的。这正好是因为函数的地址我们有一个表IDT嘛。

可是我们平时做应层面的开发工作，应该很少接触到这种编程方式吧。实际上面试被问的频率很高的一个问题：虚函数的实现-虚函数表的原理。感觉仅限于此了。


好了，我们终于完成了中断的构建。相信你到这里也终于感觉如释重负了。一旦基础的代码完成，我们再增加新的功能就变得非常简介。例如如果你想添加新的外设，或者设置新的软中断，例如后续如果要实现虚拟内存后，我们是不是应该设置一个缺页中断呢？

那这些都在irq_install()这里更改就好了，而具体的中断处理函数，依样画葫芦，就跟着键盘中断那个写就可以啦。

#### 1.中断
    CPU的两个中断管脚
    NMI：非屏蔽中断
    INTR：可屏蔽中断
    触发中断后，CPU保存当前寄存器状态，执行中断处理函数。继续之前运行的上下文。
    intel的x86架构支持256个中断。  

#### 2.中断描述符表(IDT, Interrupt Descriptor Table)：

    和段描述符表一样放置在主存中，一个中断描述符表寄存器(IDTR)记录这个表的起始地址。
    0～31号非屏蔽中断的中断描述符内容是固定的
    32~47（即由I/O 设备引起的中断）分配给屏蔽中断。比如32号是timer中断，33 号是键盘中断等等。
    48~255 用来标识软中断，比如缺页异常
    内容：中断处理函数所在代码段的选择符（这就和之前的内存分段联系起来啦），段是否在内存中的标志位，中断处理函数的地址偏移量...

#### 3.中断的执行过程

    1)CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中是否发 送中断请求过来。
    如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量。
    然后根据得到的中断向量为索引到IDT中找到该向量对应的中断描述符，中断描述符里保存着中断处理函数的段选择子;

    2)CPU使用IDT查到的中断处理函数段选择子从GDT中取得相应的段描述符，段描述符里 保存了中断处理函数的段基址和属性信息。
    此时CPU要进行一个很关键的特权检验的过程，这个涉及到CPL、RPL和DPL的数值检验以及判断是否发生用户态到内核态的切换。
    如果发生了切换，还要涉及到TSS段和用户栈和内核栈的切换;

    3)确认无误后CPU开始保存当前被打断的程序的现场(即一些寄存器的值)，以便于将来 恢复被打断的程序继续执行。
    这需要利用内核栈来保存相关现场信息，即依次压入 当前被打断程序使用的eflags、cs、eip、以及错误代码号(如果当前中断有错误代码);
    4)最后CPU会从中断描述符中取出中断处理函数的起始地址并跳转过去执行。

内核初始化时，初始化可编程控制器8259A；将中断向量IDT 表的起始地址装入IDTR 寄存器，并初始化表中的每一项。

用户进程可以通过INT指令发出一个中断请求，其中断请求向量在0～255 之间。
为了防止用户使用INT 指令模拟非法的中断和异常，必须对IDT表进行谨慎的初始化。
其措施之一就是将中断门或陷阱门中的DPL 域置为0。如果用户进程确实发出了这样一个中断请求，CPU 会检查出其CPL（3）与DPL（0）有冲突，因此产生一个“通用保护”异常。

但是，有时候必须让用户进程能够使用内核所提供的功能（比如系统调用），也就是说从用户空间进入内核空间，这可以通过把中断门或陷阱门的DPL 域置为3 来达到。

利用Intel 8259A芯片实现一个中断处理程序
可编程中断控制器8259A 的作用是负责所有来自外设的中断，其中就包括来自时钟的中断，可以通过它完成进程调度。

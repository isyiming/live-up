一、Effective Modern C++ 学习笔记

笔记的出发点：我就是要把这本书读薄～

1.从绪论开始
* 第7页：C++14的出现了一些新特性：auto、lambda、nullptr、等等，这些看来是作者要详细展开的内容，也是从这些特性开始，作者将告诉我们走向现代的C++到底是张什么样的。想到我之前用过的C++，好像auto只有在我不需要容器索引的时候，才会在循环里使用一下吧。在读本书之前，我还是一个低级的非现代C++程序菜鸟哈哈。好了，看完我这几句唠叨，绪论就可以跳过啦！
2.术语和惯例
* 第8页：提到了C++的左值和右值，我记得面试的时候被问到过。作者给了一个小技巧，只要是可以取地址的对象，那它就是左值。而像常量和函数返回值这种没办法取址的对象，就是右值了。好了记住这一点就ok了。
            class Widget{
            public:
                Widget(Widget && rhs);//因为rhs在Widget函数内部可以取址，所以它是个左值
            }
* 剩下的，跳过就完事了，我感觉有点C++基础的同学都能明白书中的惯例。比如作者说someFunc(wid)，这里wid是实参，诸如此类。
第1章.型别推导
* 条款1:理解模版编程中的型别推导
    * C++面试中几乎是所有人都会遇到的问题：C++的多态：函数重载（静态，编译时完成）、虚函数继承（动态多态）、模板编程（静态，编译时完成）。我记得这里函数重载这里，实际上编译后两个同名的函数的地址是不同的，所以在编译器看里他们就是两个函数。
    * 那么模版编程中的输入变量类型是如和被确定的？要分三种情况，举个🌰
                template<typename T>
                void f(Paramtype param);
                f(exper);//调用函数f，根据exper类型和类型修饰符Paramtype推导param的类型
        * 情况1:Paramtype是一个指针或者引用，但不是个万能引用：🌰：int& x=11; f(x);  这时候param类型为int& 。不用管x的类型修饰符中有没有&或者*，这两个符号都会别忽略。
        * 情况2:Paramtype是一个万能引用：这就要分两种情况了
            * exper是一个左值：那就还和情况1一样，比如int& x=11; f(x); param类型为int &。
            * exper是一个右值：比如f(11);  11是一个int型常量，param类型为int &&。
        * 情况3：Paramtype不是指针也不是引用
            * 那就意味着不管exper是什么类型的，param都会成为exper的一个忽略&、*、const和static等修饰词的副本。假如说exper是一个 static const int & x=11； 那么param就是一个int类型的变量。
        * 而还有一种特殊情况，就是输入的exper是一个数组的时候，我们知道数组作为函数实参输入的时候会退化为指针。所以这时候和情况1没啥区别。但是如果Paramtype是一个引用类型的时候，param会被推导为数组的引用。
        * 作者提到了一个有姿势水平的现代C++程序员在声明数组时，应该优先使用std::array<int,5>={1,2,3,4,5}; array就和我们常用的stl库里的其他容器类型一样，可以迭代器访问arr.begin()、获取容量arr.size()啥的、array相比数组的另一个优点就是，作为函数实参时不会退化为指针了。真是数组的完美替代呢。我发誓以后不会使用数组这种老旧的类型了。
* 条款2:理解auto型别推导
    * 哎，说起来auto这个修饰符我几乎不怎么用哎。但是今天发现了他的强大。
    * 使用auto x=10; 怎么理解auto的类型推导腻，没啥可理解的。这个时候auto做的工作就是条款1中提到的，自动的推导x应该是什么类型的变量。
        * auto x=100000000000;
        * cout<<"x: "<<typeid(x).name()<<endl;
        * 可以看到x是long类型的。
    * auto声明的变量初始化的时候使用auto x(11);和auto x{11};完全不同。auto x{11};不过我感觉自己不会使用{}来初始化哈哈，这个区别我就忽略掉吧。
* 条款3:理解decltype
    * decltype可以用来获取表达式的类型。有时候在泛型编程的时候，要是需要知道一个未知类型的表达式是什么类型的，就比如说：
    * template<typename Container,typenameIndex>
    * decltype(auto)
    * 我们想声明一个变量，它是和表达式：11+x 同一个类型的，但是又懒得看x的类型是什么。
    * 这时候可以decltype(11+x) y;这时候我们就声明了一个新的变量：y，它的类型和11+x这个表达式是同类型的。看起来还是挺方便的嘛。可是我作为一个非现代c++程序员，原来还没实践过泛型编程。我不够现代呀。
    * 其实使用decltype的时候还会出现一些非正常情况，例如
    * int x; decltype(x) y; //这里y是x的类型int
    * decltype((x)) y; //这里y是x的类型int& 哎，这种引用类型，都后续的程序一定十分不友好。
    * c++确实是太灵活了，这就造成一些难以想象的bug。
* 条款4:掌握查看型别推导结果的方法：
    * 方法1:cout<<"x: "<<typeid(x).name()<<endl;
    * 方法2:作者还给了一个使用boost库的方法，这个boost很厉害哦，记得用opencv pcl的时候，就都有这个库。不过我boost的方法我就不看啦
    * 这里还要提到一点，我们使用的编译器要是比较友好的话，鼠标放置在变量上呆一会，就会显示变量类型啥的，比如vs就是如此，其他的clion可能需要安装插件。这是因为编译器已经把程序编译一遍啦。
第2章
* 条款5:优先使用auto，而非显式的型别声明。
    * 作为现代的C++程序员的第一步，我再次强调，我以后一定优先使用auto，培养出良好的代码风格。毕竟之前面试官还是给我说过，代码风格很重要呀。
    * 为啥优先用auto勒，作者举了几个天真无邪的小🌰
        * 1. int x; //未经初始化的x不会引发编译错误，但是他是全局变量那就会被初始化为0了，也许它是一个局部变脸呢，那就是不确定的值啦。  
        * 但是使用auto x; //x没有初始化会报错，只能 auto x=14;//我随便赋一个14举栗子
        * 2. 作者还举了一个do want I mean 函数的例子。其实就是为了说明迭代器的声明实在又臭又长。这里我感觉作者的例子不痛不痒。不够生动，不够具体。那我来举一个例子吧！
        * vector<int>z(10,11);
        * for(auto i=z.begin();i<z.end();i++){
        *     cout<<*i<<endl;
        * }
        * for(vector<int>::iterator iter=z.begin();iter!=z.end();iter++){
        *     cout<<*iter<<endl;
        * }
        * 还是auto方便吧哈哈哈！其实还可以更简单点。
        * for(auto val:z){
        *     cout<<val<<endl;
        * }//哈哈哈我向现代C++程序员又进了一步呢
        * 3.除此之外auto还可以避免认为声明的变量类型在不同机器上结果不一致的问题。比如说32位机器上unsigned和std::vector<int>::size_type的大小是相同的，但是在64位机器上就不一样了。如果一份代码需要在两个机器上移植，你只能逐个修改了。可是用auto的时候我们可以根据已有变量来声明，这里我感觉作者举的栗子很合适。可是我懒得写了。后面作者还举了一个例子，我感觉也很好，这里就不在赘述了。44-45页，可以好好看下。
* 条款6:有时候auto声明的变量也不是完美的，会有一些特殊情况，这时候并不是说就放弃auto了。这个时候就要强制转换一下了。哎，这里还是去看作者写的吧。我感觉条款6可以看一下，工程中肯定会出现这种问题。
第3章：转向现代C++

* 整本书作者其实都在向我们介绍C++14的新特性，如何摆脱低级老旧的古代C++编程习惯？那就从掌握C++14这些新的特性开始吧！
* 条款7:在创建对象时注意区分()和{}。
    * 这一条款其实给不了我们什么建议，在初始化一个新对象的时候，到底是使用()还是{},二者各有利弊，都有自己的缺陷，有时候会造成意想不到的error。作者举了很多例子，要我说哈，这些注意事项，等我们在工程中出现了这种bug就知道啦。
* 条款8:优先选用nullptr,而非0或者NULL。
    * 其实NULL就是0，早早放弃用0表示空这种老旧的C语言方式吧。使用nullptr可以清晰的让我们知道这个类型到底是不是一个空指针。
    * 要是有一个表达式：auto res=fun(x)；//res是函数fun的返回值
    * if(res==0)  我们阅读代码的时候，也许认为res是一个NULL，也许它是一个int型的0. 那么res到底是不是指针呢，哎要是使用nullptr就没有这个问题啦，res肯定是一个指针。
* 条款9:优先使用别名声明，而非typedef
    * 如果我是一个优秀且老牌的C++程序员，那我一定会好好看看typedef到底有哪些缺点。
    * 但是我不是，所以看这一条款的时候我只需记住：别名声明是多么方便而且优雅呀～
    * 🌰：using UPtrMapSS=std::unique_ptr<std::unordered_map<std::string,std::string>>;
    * 后面就可以声明UPtrMapSS这一自定义类型的变量了。
* 条款10:优先使用限定作用域的枚举类别，而非不限作用域的枚举型别。
    * 实际上这一条款也不是绝对的要求，作者总结来总结去，结论是enmu和enum class都有各自适合的场景。
        * C++98的enmu中，如果声明了一个枚举类型比如说:
        * enmu Color {black, white, red};//编译器一般自动的为每个枚举量制定一个整数值，比如：black=1，white=2，red=3.当然也可以人为指定枚举量的值。enmu Color {black=0, white=100, red=200};
        * auto white=false;//这里是非法的，因为前面的枚举类型Color里已经把white这个标识符占用了。
        * 这里的非法情况比较反直觉哦。按照惯性思维，在一个大括号里声明的变量，他的作用域就应该是大括号内呀。可是white在Color里并不是一个变量，所以枚举量的名字占用了这个标识符。这个enmu确实很霸道哦，Color里枚举了white，包含Color的作用域就都不可以用white这个标识符了。
        * 如果我们不希望Color里的枚举量的名字染指后续的程序。那就使用enmu class 来声明枚举变量吧！
        * enmu class Color {black, white, red};
        * auto white = false;//合法的
        * 看来enmu class 这种限定作用域的枚举类型可以把enmu伸出来的手打回去，不让他管的太宽。
        * 但是有时候我们就想enmu这种霸道的类型呢，我们想要一个全局的枚举，就相当于宏定义的作用似的，而且用枚举比宏定义更方便管理呀。看来enmu和enmu class都是有用的好类型，就看我们如何使用了。
* 条款11:优先使用删除函数，而非pricate未定义函数。
    * 如果我们想要类中的某个函数无法在类外被调用，在C++98中很简单，声明为private就好了。但是现在作者说这种方法已经过时啦，C++14中引入了删除函数语法。我们可以这样做：
        * public:
        *     basic_ios(const basic_ios&)=delete;
        * 这样basic_ios这个函数就无法被调用了，即使是友元函数也不行。说实在的，我还感觉声明为private这种方法很好腻。没看出来删除函数有什么优势。我想，这是因为我的姿势水平还不够高的缘故。
    * 但是另一种情况，我感觉还是非常有道理的。作者举了一个函数重载时的例子：
    * bool isLucky(int number);
    * bool isLucky(char)=delete;
    * bool isLucky(bool)=delete;
    * 这样如果输入一个char或者bool型的参数，都是不能通过编译的。
    * 要是我写这个函数，肯定是在isLucky函数内部首先检查一下number的类型，然后函数返回值是一个枚举类型，包括true、false和一个-1来表示错误输入。这姿势水平就很低下呀。
    * 不管怎样，C++98中把函数声明为private并且不去定义，就是想要实现=delete的效果。所以强烈推荐使用删除函数。
* 条款12:为意在改写的函数添加override声明
*

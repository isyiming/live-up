一、Effective C++ 学习笔记

条款01:视C++为一个语言联邦，它由以下4种思想构成
  * C++在C的基础上构建
  * 引入面向对象的概念，多了封装继承和多态
  * 泛型编程
  * STL
条款02:尽量以const，enum，inline替换#define
  * 减少预处理器的工作，尽量用编译器来完成。
  * #define就是一个文本替换，它在内存中没有一个属于它的地址。
  * 使用const很好理解，用常量替换define的文本替换功能。
  * enmu枚举类型 显然比多个#define更加简介，尤其是函数有一个不确定的返回值的时候。
  * inline内联函数其实就是建议编译器可以将这个函数直接用文本替换的方式运行，那么在程序运行时就不会生成这个内联函数的栈，但是代码段会多了一点点开销。类内的函数默认都是内联函数.
条款03:尽可能使用const
  * const在*左边，表示指针所指对象是常量，
  * const在*右边，表示指针是常量。
  * 乘法运算 * 的返回值是一个const常量，避免出现（a*b）=c这种代码哈哈
  * 成员函数的参数列表后有const修饰的，就只能对数据成员进行读取操作
  * const修饰的成员函数fun(a,b)，其实修饰的是this->a,this->b。
条款04:确定对象被使用前已经先被初始化
  * 这个相信是很多人日常最容易犯的错误了
  * 那么我们在写一个类时，记得构造函数要完善
  * C++规定对象的成员变量的初始化发生在进入构造函数之前。
  * 在参数列表里对输入参数进行初始化：
    void fun(const int name,const int address: theName(name),theAddress(address)){}
      //这个构造函数的函数体里就不用有任何赋值的操作了。
      //反正C++默认的都会在进入fun之前就进行初始化操作（实际上是调用了default构造函数）。
      * class 的成员变量总是以其声明的顺序初始化。
    * C++对于全局警静态变量的初始化顺序没有明确规定，因为工程中有多个文件的时候，也很难确定那个静态变量应该先初始化。使用一个和你想要拥有的变量同名的函数，函数返回一个静态变量，例如你想要一个static int val；那么可以不在文件中声明它，而是使用一个 int val(){ static val; return val}
条款05:了解C++默默编写并调用了那些函数
  * 即使是一个空类，编译器也会为它声明一个copy构造函数，一个copy assignment操作符和一个析构函数。同时还会有一个默认构造函数。
条款06：若不想使用编译器自动生成的函数，就应该明确拒绝
  * 如果你的对象不想让它被复制，那么就可以声明一个private copy函数，但是不去实现它
